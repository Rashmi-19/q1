def epsilonClosure(stateTable, state):
  closure = {state}
  stack = [state]

  while stack:
    curr = stack.pop()
    if curr in stateTable and 'e' in stateTable[curr]:
        for nextState in stateTable[curr]['e']:
          if nextState not in closure:
            closure.add(nextState)
            stack.append(nextState)

  return closure

def inputSym(stateTable, state, symbol):
  closure = set()
  
  if state in stateTable and symbol in stateTable[state]:
    for nextState in stateTable[state][symbol]:
      if nextState not in closure:
            closure.add(nextState)

  return closure

def nextState(stateTable, currStates, symbol):
    move = set()
    for currState in currStates:  
        move.update(inputSym(stateTable, currState, symbol))  
    
    epsilonClosureSet = set()
    for state in move:
        epsilonClosureSet.update(epsilonClosure(stateTable, state))
    
    return epsilonClosureSet

def convertToDFA(stateTable, startState):
    processedStates = set()
    allStates = [epsilonClosure(stateTable, startState)]
    dfa = {}
    stateQueue = [frozenset(allStates[0])]  

    while stateQueue:
        currentState = stateQueue.pop(0)
        currentStateID = ''.join(sorted(currentState))  

        if currentStateID not in processedStates:
            processedStates.add(currentStateID)
            dfa[currentStateID] = {}

            for symbol in ['a', 'b']:
                nextStateSet = nextState(stateTable, currentState, symbol)
                nextStateID = ''.join(sorted(nextStateSet))
                
                if nextStateSet and frozenset(nextStateSet) not in stateQueue and frozenset(nextStateSet) not in processedStates:
                    stateQueue.append(frozenset(nextStateSet))
                    allStates.append(nextStateSet)

                if nextStateSet:
                    dfa[currentStateID][symbol] = nextStateID

    return dfa

# to name the states as A, B and so on
def convertDict(originalDict):
    stateMapping = {}
    nextName = 'A'
    for state in originalDict.keys():
        if state not in stateMapping:
            stateMapping[state] = nextName
            nextName = chr(ord(nextName) + 1)  # increment to the next letter
    
    simplifiedDict = {}
    for state, transitions in originalDict.items():
        simplifiedState = stateMapping[state]
        simplifiedTransitions = {}
        for symbol, nextState in transitions.items():
            simplifiedNextState = stateMapping[nextState]
            simplifiedTransitions[symbol] = simplifiedNextState
        simplifiedDict[simplifiedState] = simplifiedTransitions
    
    return simplifiedDict

stateTable = {
    '0-r4': {'e': ['0-r3', '0-r4']},
    '0-r3': {'e': ['0-r1', '0-r2']}, 
    '1-r3': {'e': ['0-r3', '1-r4']},
    '0-r1': {'a': ['1-r3']},
    '1-r1': {'e': ['1-r3']},
    '0-r2': {'b': ['1-r3']},
    '1-r2': {'e': ['1-r3']},
    '1-r4': {}
}

startState = '0-r4'
dfa = convertToDFA(stateTable, startState)

dfa = convertDict(dfa) # names alone

for state, transitions in dfa.items():
    print(f"State {state}:")
    for symbol, nextState in transitions.items():
        print(f"Input symbol '{symbol}' -> State {nextState}")
